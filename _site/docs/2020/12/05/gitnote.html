<p>https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304</p>

<h1 id="1创建版本库">1.创建版本库</h1>

<h2 id="1首先创建一个目录并且进入到这个目录里面">1.首先创建一个目录，并且进入到这个目录里面</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir learngit
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd learngit
</code></pre></div></div>

<h2 id="2把这个目录变成git可以管理的仓库">2.把这个目录变成git可以管理的仓库</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git init
</code></pre></div></div>

<p>输入指令后终端会告诉我们这个仓库是空的，并且该文件夹会多出一个叫做<strong>.git</strong>的隐藏目录，这个目录是git用来跟踪管理版本库的，千万不能修改里面的文件</p>

<h2 id="3创建一个文件">3.创建一个文件</h2>

<p>现在我们编写一个<code class="highlighter-rouge">readme.txt</code>文件，内容如下</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Git is a version control system.
Git is free software.
</code></pre></div></div>

<p>记住一定要放到<code class="highlighter-rouge">learngit</code>目录下，它的子目录也可以，不然无法使用git</p>

<h2 id="4把文件放到git仓库只需两步">4.把文件放到git仓库只需两步</h2>

<h3 id="41把文件添加到仓库">4.1把文件添加到仓库</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git add readme.txt
</code></pre></div></div>

<p>执行玩完上述命令，没有任何显示</p>

<h3 id="42把文件提交到仓库">4.2把文件提交到仓库</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git commit <span class="nt">-m</span> <span class="s2">"wrote a readme file"</span>
</code></pre></div></div>

<p>我们将会看到</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
</code></pre></div></div>

<p>简单解释一下，-m 后面输入的是本次提交的说明，记住一定要写，对以后我们查找文件很有帮助，这样我们就能从历史记录里面方便地找到改动记录。</p>

<h1 id="2时光机穿梭">2.时光机穿梭</h1>

<ul>
  <li>
    <p>上文中我们已经成功的创建了一个<code class="highlighter-rouge">readme.txt</code> 文件，现在实施后继续工作了，修改<code class="highlighter-rouge">readme.txt</code> 的内容如下：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Git is a distributed version control system.
Git is free software.
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="201现在查看当前的情况">2.01.现在查看当前的情况</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git status
</code></pre></div></div>

<p>我们将会看到</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>On branch master
Changes not staged <span class="k">for </span>commit:
  <span class="o">(</span>use <span class="s2">"git add &lt;file&gt;..."</span> to update what will be committed<span class="o">)</span>
  <span class="o">(</span>use <span class="s2">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="k">in </span>working directory<span class="o">)</span>

	modified:   readme.txt

no changes added to commit <span class="o">(</span>use <span class="s2">"git add"</span> and/or <span class="s2">"git commit -a"</span><span class="o">)</span>
</code></pre></div></div>

<p>上面的输出告诉我们，<code class="highlighter-rouge">readme.txt</code>被修改过了，还没有准备提交的修改</p>

<h3 id="202查看修改的情况">2.02查看修改的情况</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git diff 文件名
</code></pre></div></div>

<p>虽然Git告诉我们<code class="highlighter-rouge">readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code class="highlighter-rouge">readme.txt</code>，所以，需要用<code class="highlighter-rouge">git diff</code>这个命令看看</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git diff readme.txt 
diff <span class="nt">--git</span> a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
<span class="nt">---</span> a/readme.txt
+++ b/readme.txt
@@ <span class="nt">-1</span>,2 +1,2 @@
<span class="nt">-Git</span> is a version control system.
+Git is a distributed version control system.
 Git is free software.
</code></pre></div></div>

<p><code class="highlighter-rouge">git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的<code class="highlighter-rouge">diff</code>格式，可以从上面的命令输出看到，我们在第一行添加了一个<code class="highlighter-rouge">distributed</code>单词。</p>

<p>用<code class="highlighter-rouge">git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别。</p>

<h2 id="21版本回退">2.1版本回退</h2>

<h3 id="211查看历史记录">2.1.1查看历史记录</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git log
</code></pre></div></div>

<p>输出如下</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="o">(</span>HEAD -&gt; master<span class="o">)</span>
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre></div></div>

<p><code class="highlighter-rouge">git log</code>命令显示从<strong>最近到最远的提交日志</strong>，我们可以看到3次提交，最近的一次是<code class="highlighter-rouge">append GPL</code>，上一次是<code class="highlighter-rouge">add distributed</code>，最早的一次是<code class="highlighter-rouge">wrote a readme file</code>。</p>

<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code class="highlighter-rouge">--pretty=oneline</code>参数：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git log <span class="nt">--pretty</span><span class="o">=</span>oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="o">(</span>HEAD -&gt; master<span class="o">)</span> append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
</code></pre></div></div>

<p>你看到的一大串类似<code class="highlighter-rouge">1094adb...</code>的是<code class="highlighter-rouge">commit id</code>（版本号），和SVN不一样，Git的<code class="highlighter-rouge">commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code class="highlighter-rouge">commit id</code>和我的肯定不一样，以你自己的为准。为什么<code class="highlighter-rouge">commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>

<h3 id="212从现在回到过去">2.12从现在回到过去</h3>

<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code class="highlighter-rouge">HEAD</code>表示当前版本，也就是最新的提交<code class="highlighter-rouge">1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code class="highlighter-rouge">HEAD^</code>，上上一个版本就是<code class="highlighter-rouge">HEAD^^</code>，当然往上100个版本写100个<code class="highlighter-rouge">^</code>比较容易数不过来，所以写成<code class="highlighter-rouge">HEAD~100</code>。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git reset <span class="nt">--hard</span> HEAD^
</code></pre></div></div>

<p>如果你知道回退的版本号是多少，那么可以使用下面的方法</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git reset <span class="nt">--hard</span> 版本号
</code></pre></div></div>

<p><code class="highlighter-rouge">--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p>

<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code class="highlighter-rouge">HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code class="highlighter-rouge">append GPL</code>：</p>

<pre><code class="language-ascii">┌────┐
│HEAD│
└────┘
   │
   └──&gt; ○ append GPL
        │
        ○ add distributed
        │
        ○ wrote a readme file
</code></pre>

<p>改为指向<code class="highlighter-rouge">add distributed</code>：</p>

<pre><code class="language-ascii">┌────┐
│HEAD│
└────┘
   │
   │    ○ append GPL
   │    │
   └──&gt; ○ add distributed
        │
        ○ wrote a readme file
</code></pre>

<p>然后顺便把工作区的文件更新了。所以你让<code class="highlighter-rouge">HEAD</code>指向哪个版本号，你就把当前版本定位在哪，<strong>回去以后，在使用<code class="highlighter-rouge">git log</code>就看不到回退版本之前的版本了</strong>。</p>

<h3 id="213从过去回到未来">2.13从过去回到未来</h3>

<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code class="highlighter-rouge">commit id</code>怎么办？</p>

<p>在Git中，总是有后悔药可以吃的。当你用<code class="highlighter-rouge">$ git reset --hard HEAD^</code>回退到<code class="highlighter-rouge">add distributed</code>版本时，再想恢复到<code class="highlighter-rouge">append GPL</code>，就必须找到<code class="highlighter-rouge">append GPL</code>的commit id。Git提供了一个命令<code class="highlighter-rouge">git reflog</code>用来<strong>记录你的每一次命令</strong>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git reflog
</code></pre></div></div>

<p>你将看到类似于下面的内容</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>e475afc HEAD@<span class="o">{</span>1<span class="o">}</span>: reset: moving to HEAD^
1094adb <span class="o">(</span>HEAD -&gt; master<span class="o">)</span> HEAD@<span class="o">{</span>2<span class="o">}</span>: commit: append GPL
e475afc HEAD@<span class="o">{</span>3<span class="o">}</span>: commit: add distributed
eaadf4e HEAD@<span class="o">{</span>4<span class="o">}</span>: commit <span class="o">(</span>initial<span class="o">)</span>: wrote a readme file
</code></pre></div></div>

<p>终于舒了口气，从输出可知，<code class="highlighter-rouge">append GPL</code>的commit id是<code class="highlighter-rouge">1094adb</code>，现在，可以使用<strong>调用版本号回退</strong>的方法，你又可以乘坐时光机回到未来了。</p>

<h3 id="214小结">2.14小结</h3>

<ul>
  <li><code class="highlighter-rouge">HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code class="highlighter-rouge">git reset --hard commit_id</code>。</li>
  <li>穿梭前，用<code class="highlighter-rouge">git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
  <li>要重返未来，用<code class="highlighter-rouge">git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>

<h2 id="22工作区和暂存区">2.2工作区和暂存区</h2>

<h3 id="221工作区working-directory">2.2.1工作区（Working Directory）</h3>

<p>就是你在电脑里能看到的目录，比如我的<code class="highlighter-rouge">learngit</code>文件夹就是一个工作区：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919021113952544/0" alt="working-dir" /></p>

<h3 id="222版本库repository">2.2.2版本库（Repository）</h3>

<p>工作区有一个隐藏目录<code class="highlighter-rouge">.git</code>，这个不算工作区，而是Git的版本库。</p>

<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code class="highlighter-rouge">master</code>，以及指向<code class="highlighter-rouge">master</code>的一个指针叫<code class="highlighter-rouge">HEAD</code>。</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo" /></p>

<p>分支和<code class="highlighter-rouge">HEAD</code>的概念我们以后再讲。</p>

<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>

<p>第一步是用<code class="highlighter-rouge">git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>

<p>第二步是用<code class="highlighter-rouge">git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>

<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code class="highlighter-rouge">master</code>分支，所以，现在，<code class="highlighter-rouge">git commit</code>就是往<code class="highlighter-rouge">master</code>分支上提交更改。</p>

<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>

<p><strong><code class="highlighter-rouge">git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code class="highlighter-rouge">git commit</code>就可以一次性把暂存区的所有修改提交到分支。</strong></p>

<h2 id="23管理修改">2.3管理修改</h2>

<p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>

<p>第一次修改 -&gt; <code class="highlighter-rouge">git add</code> -&gt; 第二次修改 -&gt; <code class="highlighter-rouge">git commit</code></p>

<p>你看，我们前面讲了，Git管理的是修改，当你用<code class="highlighter-rouge">git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code class="highlighter-rouge">git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>

<p>那怎么提交第二次修改呢？你可以继续<code class="highlighter-rouge">git add</code>再<code class="highlighter-rouge">git commit</code>，也可以别着急提交第一次修改，先<code class="highlighter-rouge">git add</code>第二次修改，再<code class="highlighter-rouge">git commit</code>，就相当于把两次修改合并后一块提交了：</p>

<p>第一次修改 -&gt; <code class="highlighter-rouge">git add</code> -&gt; 第二次修改 -&gt; <code class="highlighter-rouge">git add</code> -&gt; <code class="highlighter-rouge">git commit</code></p>

<h2 id="24撤销修改">2.4撤销修改</h2>

<h3 id="241放弃对工作区的改动">2.4.1放弃对工作区的改动</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git checkout <span class="nt">--</span> 文件名
</code></pre></div></div>

<p>或者使用</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git restore 文件名
</code></pre></div></div>

<p>命令<code class="highlighter-rouge">git checkout -- readme.txt</code>意思就是，把<code class="highlighter-rouge">readme.txt</code>文件在工<strong>作区的修改</strong>全部撤销，这里有两种情况：</p>

<p>一种是<code class="highlighter-rouge">readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>

<p>一种是<code class="highlighter-rouge">readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>

<p>总之，就是让这个文件回到最近一次<code class="highlighter-rouge">git commit</code>或<code class="highlighter-rouge">git add</code>时的状态。</p>

<p><code class="highlighter-rouge">git checkout -- file</code>命令中的<code class="highlighter-rouge">--</code>很重要，没有<code class="highlighter-rouge">--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code class="highlighter-rouge">git checkout</code>命令。</p>

<h3 id="242放弃对暂存区的修改并重新放回工作区">2.4.2放弃对暂存区的修改并重新放回工作区</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git reset HEAD 文件名
</code></pre></div></div>

<p>也可以使用</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git restore <span class="nt">--staged</span> 文件名
</code></pre></div></div>

<p><code class="highlighter-rouge">git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code class="highlighter-rouge">HEAD</code>时，表示最新的版本。</p>

<h2 id="25删除文件">2.5删除文件</h2>

<h3 id="1确实想要把文件删除">1.确实想要把文件删除</h3>

<ol>
  <li>首先将文件删除</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git <span class="nb">rm </span>test.txt
</code></pre></div></div>

<p>​	会有输出语句</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm 'test.txt'
</code></pre></div></div>

<ol>
  <li>
    <p>提交删除结果到版本库</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git commit <span class="nt">-m</span> <span class="s2">"说明，一般是'remove 文件名'"</span>
</code></pre></div>    </div>

    <p>会有输出语句</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>master d46f35e] remove test.txt
 1 file changed, 1 deletion<span class="o">(</span>-<span class="o">)</span>
 delete mode 100644 test.txt
</code></pre></div>    </div>

    <p>现在文件就从版本库中删除了。</p>
  </li>
</ol>

<h3 id="2误删文件如何还原呢">2.误删文件，如何还原呢</h3>

<p>因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git checkout <span class="nt">--</span> 文件名
</code></pre></div></div>

<p><code class="highlighter-rouge">git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>

<p>命令<code class="highlighter-rouge">git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>

<h1 id="3远程仓库">3.远程仓库</h1>

<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>

<p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p>

<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p>

<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>

<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个<code class="highlighter-rouge">GitHub</code>账号，就可以免费获得Git远程仓库。</p>

<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>

<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code class="highlighter-rouge">id_rsa</code>和<code class="highlighter-rouge">id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ssh-keygen -t rsa -C "youremail@example.com"
</code></pre></div></div>

<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>

<p>如果一切顺利的话，可以在用户主目录里找到<code class="highlighter-rouge">.ssh</code>目录，里面有<code class="highlighter-rouge">id_rsa</code>和<code class="highlighter-rouge">id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code class="highlighter-rouge">id_rsa</code>是私钥，不能泄露出去，<code class="highlighter-rouge">id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>

<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>

<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code class="highlighter-rouge">id_rsa.pub</code>文件的内容：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919021379029408/0" alt="github-addkey-1" /></p>

<p>点“Add Key”，你就应该看到已经添加的Key：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919021395420160/0" alt="github-addkey-2" /></p>

<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>

<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>

<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>

<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>

<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>

<h2 id="31添加远程仓库">3.1添加远程仓库</h2>

<p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>

<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919021631860000/0" alt="github-create-repo-1" /></p>

<p>在Repository name填入<code class="highlighter-rouge">learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919021652277920/0" alt="github-create-repo-2" /></p>

<p>目前，在GitHub上的这个<code class="highlighter-rouge">learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>

<p>现在，我们根据GitHub的提示，看到网站中的push an existing ….</p>

<p>下面会有具体的代码，我们就在本地的learngit仓库中敲这三行代码即可：</p>

<p>中间注意要填写自己GitHub的用户名和密码，看到以下界面</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201163250870.png" alt="image-20201201163250870" /></p>

<p>敲完代码后，，然后刷新一下GitHub页面就可以看到远程库的内容已经和本地一模一样</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201163443299.png" alt="image-20201201163443299" /></p>

<p>从现在起，只要本地作了提交，就可以通过命令：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git push origin 分支名
</code></pre></div></div>

<p>可以看到我的分支名为main,所以我就可以把本地<code class="highlighter-rouge">main</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201164742043.png" alt="image-20201201164742043" /></p>

<p>接下来我可以在<code class="highlighter-rouge">GitHub</code>看到我刚刚添加的文件：</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201164845000.png" alt="image-20201201164845000" /></p>

<h2 id="32从远程库克隆">3.2从远程库克隆</h2>

<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>

<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>

<p>首先，登陆GitHub，创建一个新的仓库，名字叫<code class="highlighter-rouge">gitskills</code>：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919021808263616/0" alt="github-init-repo" /></p>

<p>我们勾选<code class="highlighter-rouge">Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code class="highlighter-rouge">README.md</code>文件。创建完毕后，可以看到<code class="highlighter-rouge">README.md</code>文件：</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201165206115.png" alt="image-20201201165206115" /></p>

<p>现在，远程库已经准备好了，下一步是</p>

<h3 id="1用命令git-clone克隆一个本地库">1.用命令<code class="highlighter-rouge">git clone</code>克隆一个本地库：</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone git@github.com:用户名/库名.git
</code></pre></div></div>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201165753198.png" alt="image-20201201165753198" /></p>

<p>进入<code class="highlighter-rouge">gitskills</code>目录看看，已经有<code class="highlighter-rouge">README.md</code>文件了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>gitskills
<span class="nv">$ </span><span class="nb">ls
</span>README.md
</code></pre></div></div>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201165839210.png" alt="image-20201201165839210" /></p>

<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>

<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code class="highlighter-rouge">https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code class="highlighter-rouge">git://</code>使用ssh，但也可以使用<code class="highlighter-rouge">https</code>等其他协议。</p>

<p>使用<code class="highlighter-rouge">https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code class="highlighter-rouge">ssh</code>协议而只能用<code class="highlighter-rouge">https</code>。</p>

<h3 id="小结">小结</h3>

<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code class="highlighter-rouge">git clone</code>命令克隆。</p>

<p>Git支持多种协议，包括<code class="highlighter-rouge">https</code>，但<code class="highlighter-rouge">ssh</code>协议速度最快。</p>

<h1 id="4分支管理">4.分支管理</h1>

<p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>

<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919021987875136/0" alt="learn-branches" /></p>

<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>

<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>

<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>

<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>

<h2 id="41创建与合并分支">4.1创建与合并分支</h2>

<p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code class="highlighter-rouge">master</code>分支。<code class="highlighter-rouge">HEAD</code>严格来说不是指向提交，而是指向<code class="highlighter-rouge">master</code>，<code class="highlighter-rouge">master</code>才是指向提交的，所以，<code class="highlighter-rouge">HEAD</code>指向的就是当前分支。</p>

<p>一开始的时候，<code class="highlighter-rouge">master</code>分支是一条线，Git用<code class="highlighter-rouge">master</code>指向最新的提交，再用<code class="highlighter-rouge">HEAD</code>指向<code class="highlighter-rouge">master</code>，就能确定当前分支，以及当前分支的提交点：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919022325462368/0" alt="git-br-initial" /></p>

<p>每次提交，<code class="highlighter-rouge">master</code>分支都会向前移动一步，这样，随着你不断提交，<code class="highlighter-rouge">master</code>分支的线也越来越长。</p>

<p>当我们创建新的分支，例如<code class="highlighter-rouge">dev</code>时，Git新建了一个指针叫<code class="highlighter-rouge">dev</code>，指向<code class="highlighter-rouge">master</code>相同的提交，再把<code class="highlighter-rouge">HEAD</code>指向<code class="highlighter-rouge">dev</code>，就表示当前分支在<code class="highlighter-rouge">dev</code>上：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919022363210080/l" alt="git-br-create" /></p>

<p>你看，Git创建一个分支很快，因为除了增加一个<code class="highlighter-rouge">dev</code>指针，改改<code class="highlighter-rouge">HEAD</code>的指向，工作区的文件都没有任何变化！</p>

<p>不过，从现在开始，对工作区的修改和提交就是针对<code class="highlighter-rouge">dev</code>分支了，比如新提交一次后，<code class="highlighter-rouge">dev</code>指针往前移动一步，而<code class="highlighter-rouge">master</code>指针不变：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919022387118368/l" alt="git-br-dev-fd" /></p>

<p>假如我们在<code class="highlighter-rouge">dev</code>上的工作完成了，就可以把<code class="highlighter-rouge">dev</code>合并到<code class="highlighter-rouge">master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code class="highlighter-rouge">master</code>指向<code class="highlighter-rouge">dev</code>的当前提交，就完成了合并：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge" /></p>

<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>

<p>合并完分支后，甚至可以删除<code class="highlighter-rouge">dev</code>分支。删除<code class="highlighter-rouge">dev</code>分支就是把<code class="highlighter-rouge">dev</code>指针给删掉，删掉后，我们就剩下了一条<code class="highlighter-rouge">master</code>分支：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919022479428512/0" alt="git-br-rm" /></p>

<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>

<p>下面开始实战。</p>

<h3 id="411创建并切换到分支">4.1.1创建并切换到分支</h3>

<p><strong>创建并切换到新的<code class="highlighter-rouge">dev</code>分支，可以使用：</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git switch <span class="nt">-c</span> dev
</code></pre></div></div>

<p>直接切换到已有的<code class="highlighter-rouge">master</code>分支，可以使用：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git switch master
</code></pre></div></div>

<p><strong>使用新的<code class="highlighter-rouge">git switch</code>命令，比<code class="highlighter-rouge">git checkout</code>要更容易理解。</strong></p>

<p>也可以使用下面的指令</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$git</span> checkout <span class="nt">-b</span> 分支名称
</code></pre></div></div>

<p><code class="highlighter-rouge">git checkout</code>命令加上<code class="highlighter-rouge">-b</code>参数表示创建并切换，相当于以下两条命令：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git branch dev
<span class="nv">$ </span>git checkout dev
Switched to branch <span class="s1">'dev'</span>
</code></pre></div></div>

<p>以上两条命令分别代表<strong>创建分支</strong>和<strong>切换分支</strong></p>

<h3 id="412查看当前分支">4.1.2查看当前分支：</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch
* dev
  master
</code></pre></div></div>

<p><code class="highlighter-rouge">git branch</code>命令会列出所有分支，当前分支前面会标一个<code class="highlighter-rouge">*</code>号。</p>

<p>然后，我们就可以在<code class="highlighter-rouge">dev</code>分支上正常提交，比如对<code class="highlighter-rouge">readme.txt</code>做个修改，加上一行：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating a new branch is quick.
</code></pre></div></div>

<p>然后提交：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git add readme.txt 
<span class="nv">$ </span>git commit <span class="nt">-m</span> <span class="s2">"branch test"</span>
<span class="o">[</span>dev b17d20e] branch <span class="nb">test
 </span>1 file changed, 1 insertion<span class="o">(</span>+<span class="o">)</span>
</code></pre></div></div>

<p>现在<code class="highlighter-rouge">dev</code>分支的工作完成了，我可以切换到原来的main分支：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git checkout main
</code></pre></div></div>

<p>切换回<code class="highlighter-rouge">master</code>分支后，再查看一个<code class="highlighter-rouge">readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code class="highlighter-rouge">dev</code>分支上，而<code class="highlighter-rouge">master</code>分支此刻的提交点并没有变：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919022533080576/0" alt="git-br-on-master" /></p>

<h3 id="413把其他分支的工作成果合并到main分支上">4.1.3把其他分支的工作成果合并到main分支上</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git merge 分支名
</code></pre></div></div>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201195115991.png" alt="image-20201201195115991" /></p>

<p><code class="highlighter-rouge">git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code class="highlighter-rouge">readme.txt</code>的内容，就可以看到，和<code class="highlighter-rouge">dev</code>分支的最新提交是完全一样的。</p>

<p>注意到上面的<code class="highlighter-rouge">Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code class="highlighter-rouge">master</code>指向<code class="highlighter-rouge">dev</code>的当前提交，所以合并速度非常快。</p>

<p>当然，也不是每次合并都能<code class="highlighter-rouge">Fast-forward</code>，我们后面会讲其他方式的合并。</p>

<h3 id="414删除分支">4.1.4删除分支</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git branch <span class="nt">-d</span> 分支名称
</code></pre></div></div>

<p>现在我们来删除dev 分支吧</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201195304589.png" alt="image-20201201195304589" /></p>

<p>现在再来看，就只剩下main分支了</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201195401736.png" alt="" /></p>

<h2 id="42解决冲突">4.2解决冲突</h2>

<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>

<p>准备新的<code class="highlighter-rouge">feature1</code>分支，继续我们的新分支开发：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git switch <span class="nt">-c</span> feature1
Switched to a new branch <span class="s1">'feature1'</span>
</code></pre></div></div>

<p>修改<code class="highlighter-rouge">readme.txt</code>最后一行，改为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating a new branch is quick AND simple.
</code></pre></div></div>

<p>在<code class="highlighter-rouge">feature1</code>分支上提交：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add readme.txt

$ git commit -m "AND simple"
[feature1 14096d0] AND simple
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre></div></div>

<p>切换到<code class="highlighter-rouge">master</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git switch master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
</code></pre></div></div>

<p>Git还会自动提示我们当前<code class="highlighter-rouge">master</code>分支比远程的<code class="highlighter-rouge">master</code>分支要超前1个提交。</p>

<p>在<code class="highlighter-rouge">master</code>分支上把<code class="highlighter-rouge">readme.txt</code>文件的最后一行改为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Creating a new branch is quick &amp; simple.
</code></pre></div></div>

<p>提交：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add readme.txt 
$ git commit -m "&amp; simple"
[master 5dc6824] &amp; simple
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre></div></div>

<p>现在，<code class="highlighter-rouge">master分支和</code>feature1`分支各自都分别有新的提交，变成了这样：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919023000423040/0" alt="git-br-feature1" /></p>

<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>

<p><img src="file:///home/xjk/.config/Typora/typora-user-images/image-20201201202752878.png?lastModify=1606825661" alt="image-20201201202752878" /></p>

<p>可以直接查看readme.txt的内容：</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201202904522.png" alt="image-20201201202904522" /></p>

<p>Git用<code class="highlighter-rouge">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code class="highlighter-rouge">=======</code>，<code class="highlighter-rouge">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容,我们做出如下修改，把里面的内容改成”135”；</p>

<p>再提交：</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201203217182.png" alt="image-20201201203217182" /></p>

<p>现在，<code class="highlighter-rouge">master分支和</code>feature1`分支变成了下图所示：</p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919023031831104/0" alt="git-br-conflict-merged" /></p>

<h3 id="421查看分支的合并情况">4.2.1查看分支的合并情况</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git log <span class="nt">--graph</span> <span class="nt">--pretty</span><span class="o">=</span>oneline <span class="nt">--abbrev-commit</span>
</code></pre></div></div>

<p>因为我实验了两次，所以我会有一条featurel分支和一条test1分支</p>

<p>log 后面的参数都是为了简化这个图的内容而加的</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201203635377.png" alt="image-20201201203635377" /></p>

<h2 id="43分支管理策略">4.3分支管理策略</h2>

<p>通常，合并分支时，如果可能，Git会用<code class="highlighter-rouge">Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>

<p>如果要强制禁用<code class="highlighter-rouge">Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>

<p>下面我们实战一下<code class="highlighter-rouge">--no-ff</code>方式的<code class="highlighter-rouge">git merge</code>：</p>

<p>首先，仍然创建并切换<code class="highlighter-rouge">dev</code>分支：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git switch -c dev
Switched to a new branch 'dev'
</code></pre></div></div>

<p>修改readme.txt文件，并提交一个新的commit：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add readme.txt 
$ git commit -m "add merge"
[dev f52c633] add merge
 1 file changed, 1 insertion(+)
</code></pre></div></div>

<p>现在，我们切换回<code class="highlighter-rouge">master</code>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git switch master
Switched to branch 'master'
</code></pre></div></div>

<h3 id="--no-ff参数表示禁用fast-forward合并"><code class="highlighter-rouge">--no-ff</code>参数，表示禁用<code class="highlighter-rouge">Fast forward</code>合并：</h3>

<p><strong>合并分支时，加上<code class="highlighter-rouge">--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code class="highlighter-rouge">fast forward</code>合并就看不出来曾经做过合并。</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git merge --no-ff -m "merge with no-ff" dev
Merge made by the 'recursive' strategy.
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
</code></pre></div></div>

<p>因为本次合并要创建一个新的commit，所以加上<code class="highlighter-rouge">-m</code>参数，把commit描述写进去。</p>

<p>合并后，我们用<code class="highlighter-rouge">git log</code>看看分支历史：</p>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201201204718411.png" alt="image-20201201204718411" /></p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode" /></p>

<p><strong>我们再来对比一下不使用’–no-ff’参数的图</strong></p>

<p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge" /></p>

<p>可见master并没有直接指向Dev的创建的节点了，而是自己创造再一个节点，将dev连接起来.</p>

<h2 id="44bug分支">4.4Bug分支</h2>

<h3 id="441把当前工作现场储藏起来等以后恢复现场后继续工作">4.4.1把当前工作现场“储藏”起来，等以后恢复现场后继续工作</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git stash
</code></pre></div></div>

<h3 id="442查看隐藏的工作现场">4.4.2查看隐藏的工作现场</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git stash list
</code></pre></div></div>

<h3 id="443恢复工作现场但不删除stash中的内容">4.4.3恢复工作现场但不删除stash中的内容</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git stash apply
</code></pre></div></div>

<h3 id="444恢复工作现场并且删除stash中的内容">4.4.4恢复工作现场并且删除stash中的内容</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git stash pop
</code></pre></div></div>

<p>此时在使用git stash list 就看不到任何内容了</p>

<h3 id="445复制一个特定的提交到当前分支">4.4.5复制一个特定的提交到当前分支</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git cheery-pick 文件id
</code></pre></div></div>

<p>例如:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git cherry-pick 4c805e2
</code></pre></div></div>

<h3 id="小结-1">小结</h3>

<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>

<p>当手头工作没有完成时，先把工作现场<code class="highlighter-rouge">git stash</code>一下，然后去修复bug，修复后，再<code class="highlighter-rouge">git stash pop</code>，回到工作现场；</p>

<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code class="highlighter-rouge">git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>

<h2 id="45feature分支">4.5Feature分支</h2>

<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>

<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>

<h3 id="451丢弃未合并的分支强制删除">4.5.1丢弃未合并的分支,强制删除</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git branch <span class="nt">-D</span> 分支名
</code></pre></div></div>

<h2 id="46多人协作">4.6多人协作</h2>

<p>当你从远程仓库克隆时，实际上Git自动把本地的<code class="highlighter-rouge">master</code>分支和远程的<code class="highlighter-rouge">master</code>分支对应起来了，并且，远程仓库的默认名称是<code class="highlighter-rouge">origin</code>。</p>

<h3 id="461查看远程库的信息">4.6.1查看远程库的信息</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git remote
</code></pre></div></div>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201203152210136.png" alt="image-20201203152210136" /></p>

<h3 id="461查看远程库更加详细的信息">4.6.1查看远程库更加详细的信息</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git remote <span class="nt">-v</span>
</code></pre></div></div>

<p><img src="/home/xjk/.config/Typora/typora-user-images/image-20201203152332821.png" alt="image-20201203152332821" />上面显示了可以抓取和推送的<code class="highlighter-rouge">origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>

<h3 id="462推送分支">4.6.2推送分支</h3>

<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git push origin 分知名
</code></pre></div></div>

<p>比如我现在把main分支推送到远程库分支上</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git push origin main
</code></pre></div></div>

<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>

<ul>
  <li><code class="highlighter-rouge">master</code>分支是主分支，因此要时刻与远程同步；</li>
  <li><code class="highlighter-rouge">dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
  <li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
  <li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>

<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>

<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆,当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code class="highlighter-rouge">master</code>分支。不信可以用<code class="highlighter-rouge">git branch</code>命令看看：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git branch
<span class="k">*</span> master
</code></pre></div></div>

<h3 id="463创建远程origin的分支到本地">4.6.3创建远程origin的分支到本地</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git checkout <span class="nt">-b</span> 分支名 origin/分支名
</code></pre></div></div>

<p>比如就必须创建远程<code class="highlighter-rouge">origin</code>的<code class="highlighter-rouge">dev</code>分支到本地，于是他用这个命令创建本地<code class="highlighter-rouge">dev</code>分支：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git checkout <span class="nt">-b</span> dev origin/dev
</code></pre></div></div>

<h3 id="464抓取分支">4.6.4抓取分支</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git pull
</code></pre></div></div>

<p>该操作可能会失败，原因时没有指定本地<code class="highlighter-rouge">dev</code>分支与远程<code class="highlighter-rouge">origin/dev</code>分支的链接，根据提示，设置<code class="highlighter-rouge">dev</code>和<code class="highlighter-rouge">origin/dev</code>的链接，所以在执行以下操作：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git branch <span class="nt">--set-upstream-to</span><span class="o">=</span>origin/dev dev
Branch <span class="s1">'dev'</span> <span class="nb">set </span>up to track remote branch <span class="s1">'dev'</span> from <span class="s1">'origin'</span><span class="nb">.</span>

</code></pre></div></div>

<h3 id="小结-2">小结</h3>

<p>因此，多人协作的工作模式通常是这样：</p>

<ol>
  <li>首先，可以试图用<code class="highlighter-rouge">git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
  <li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code class="highlighter-rouge">git pull</code>试图合并；</li>
  <li>如果合并有冲突，则解决冲突，并在本地提交；</li>
  <li>没有冲突或者解决掉冲突后，再用<code class="highlighter-rouge">git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>

<p>如果<code class="highlighter-rouge">git pull</code>提示<code class="highlighter-rouge">no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code class="highlighter-rouge">git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>

<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>

<h2 id="47rebase">4.7rebase</h2>

<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>

<p>每次合并再push后，分支变成了这样：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git log --graph --pretty=oneline --abbrev-commit
* d1be385 (HEAD -&gt; master, origin/master) init hello
*   e5e69f1 Merge branch 'dev'
|\  
| *   57c53ab (origin/dev, dev) fix env conflict
| |\  
| | * 7a5e5dd add env
| * | 7bd91f1 add new env
| |/  
* |   12a631b merged bug fix 101
|\ \  
| * | 4c805e2 fix bug 101
|/ /  
* |   e1e9c68 merge with no-ff
|\ \  
| |/  
| * f52c633 add merge
|/  
*   cf810e4 conflict fixed
</code></pre></div></div>

<h3 id="整理分叉使其变成一条直线">整理分叉，使其变成一条直线</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git rebase
</code></pre></div></div>

<p>会输出一大堆东西，然后使用git log查看效果</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git log --graph --pretty=oneline --abbrev-commit
* 7e61ed4 (HEAD -&gt; master, origin/master) add author
* 3611cfe add comment
* f005ed4 set exit=1
* d1be385 init hello
...
</code></pre></div></div>
